{% extends "base.html" %}

{% block head %}
  <link rel="stylesheet prefetch" href="/themes/uiuctf-2023-ctfd-theme/static/windows-95-ui-kit/css/bootstrap.min.css">
  <link rel="stylesheet prefetch" href="/themes/uiuctf-2023-ctfd-theme/static/windows-95-ui-kit/css/w95.css">
  <script src="//daybrush.com/moveable/release/latest/dist/moveable.min.js"></script>

  <style>
    /* Moveable.js overrides */
    .moveable-line {
      height: 15px !important;
      opacity: 0 !important;
    }
    .moveable-control {
      opacity: 0 !important;
    }

    body {
      overflow: hidden;
    }

    #taskbar {
      z-index: 2000;
    }

    .start-button {
      font-weight: bold !important;
      margin-right: 4px !important;
    }

    .start-menu-container {
      position: absolute;
      height: 238px;
      width: 164px;
      /* background-color: red; */
    }

    .start-menu {
      position: relative;
      top: -100%;
      height: 100%;
      width: 100%;
      display: flex;
      flex-flow: row;
      background-color: #c0c0c0;
      border-top: 2px solid #ffffff;
      border-left: 2px solid #ffffff;
      border-bottom: 2px solid #000000;
      border-right: 2px solid #000000;
    }

    .start-menu .logo-bar {
      background-color: #808080;
      width: 21px;
      margin-top: 1px;
      margin-left: 1px;
      margin-right: 0px;
      margin-bottom: 1px;
      padding-bottom: 7px;
      display: flex;
      justify-content: center;
      align-items: end;
      image-rendering: pixelated;
    }

    .start-menu .main-options {
      display: flex;
      flex-flow: column;
      flex-grow: 1;
      justify-content: center;
    }

    .start-menu .main-options > div {
      display: flex;
      flex-flow: row;
      flex-grow: 1;
      align-items: center;
      padding-left: 10px;
      padding-right: 7px;
    }

    .start-menu .main-options > div:hover {
      background-color: #000080;
      color: #ffffff;
    }

    .pane {
      overflow-x: hidden;
      overflow-y: hidden;
      position: absolute;
      top: 0;
      left: 0;
      min-width: 128px;
      min-height: 64px;
    }

    .card-header-content {
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
      user-select: none;
    }

    .card-body {
      max-height: 100%;
      overflow-y: auto;
    }

    .pane-control-icon {
      image-rendering: pixelated;
      user-select: none;
    }
    .pane-control-icon > img {
      pointer-events: none;
      display: none;
      height: 0.875rem;
    }
    .pane-control-icon > img:first-child {
      display: block;
    }
    .pane-control-icon:active > img:first-child {
      display: none;
    }
    .pane-control-icon:active > img:last-child {
      display: block;
    }
    .close-icon {
      margin-left: 0.125rem;
    }
  </style>

  <script type="text/javascript">
    document.addEventListener('alpine:init', () => {
      // Alpine.store("desktop-panes", {
      //   panes: Alpine.$persist([])
      // })
      Alpine.data('mydata', () => ({
        init() {
          // TODO: Move classes into a separate JS file
          // TODO: Initial window start (brand new session)
          class Pane {
            constructor(params) {
              // Check required parameters
              if (!params.id) throw new Error("Pane must have an id");
              if (!params.target) throw new Error("Pane must have a target");
              if (!params.handle) throw new Error("Pane needs a handle... for now");
              if (!params.title) throw new Error("Pane must have a title");
              console.log("Checks passed!")
              this.id = params.id; // this must be unique within a Desktop
              this.target = params.target;
              this.handle = params.handle;
              this.taskbar = params.taskbar || null;
              // TODO: title and icon_path
              this.title = params.title;
              this.icon_path = params.icon_path || null; // TODO: change to ??

              this.desktop = null; // populated by Desktop.add()

              this.transform = params.transform ?? `translate(${params.x ?? 0}px, ${params.y ?? 0}px)`;
              this.z = params.z ?? 0;
              // this.width = target.offsetWidth;
              this.width = params.width ?? 500;
              this.height = params.height ?? 500;
              this.minimized = params.minimized ?? false;
              this.maximized = params.maximized ?? false;
              this.focused = params.focused ?? false; // TODO: Change to true if new window

              this.moveable = new Moveable(document.body, {
                target: this.target,
                dragTarget: this.handle ?? null,
                // Draggable options
                draggable: !this.maximized,
                throttleDrag: 1,
                edgeDraggable: false,
                startDragRotate: 0,
                throttleDragRotate: 0,
                edge: true,
                origin: false,
                // Resizable options
                resizable: !this.maximized,
                throttleResize: 1,
                keepRatio: false,
                renderDirections: ["nw", "ne", "se", "sw"],
              });
              this.registerListeners();
              this.render();
            }

            /**
             * Registers event listeners for all components used to control the pane
             */
            registerListeners() {
              this.moveable.on("drag", e => {
                e.target.style.transform = e.transform;
                if (this.maximized) this.setMaximized(false);
              });
              this.moveable.on("resize", e => {
                e.target.style.transform = e.transform;
                e.target.style.width = `${e.width}px`;
                e.target.style.height = `${e.height}px`;
              });
              this.moveable.on("dragStart", e => {
                this.desktop.bringToFront(this.target);
              });
              this.moveable.on("resizeStart", e => {
                this.desktop.bringToFront(this.target);
              });
              this.moveable.on("dragEnd", e => {
                if (!this.maximized) {
                  this.transform = e.target.style.transform;
                }
                this.desktop.save();
              });
              this.moveable.on("resizeEnd", e => {
                this.transform = e.target.style.transform;
                this.width = e.target.style.width;
                this.height = e.target.style.height;
                this.desktop.save();
              });
              // If any part of the pane is clicked, bring it to the front
              this.target.addEventListener("click", () => {
                this.desktop.bringToFront(this.target);
              });
              // Maximize/restore on handle double click
              this.handle.addEventListener("dblclick", () => {
                this.setMaximized(!this.maximized);
                this.render();
                this.desktop.save();
              });
              // Minimize buttons
              this.target.querySelectorAll("div[x-ref='minimize']").forEach(
                elem => elem.addEventListener("click", (event) => {
                  this.setMinimized(true);
                  event.stopImmediatePropagation();
                })
              )
              // Maximize buttons
              this.target.querySelectorAll("div[x-ref='maximize']").forEach(
                elem => elem.addEventListener("click", (event) => {
                  this.setMaximized(true);
                  event.stopImmediatePropagation();
                })
              )
              // Restore buttons
              this.target.querySelectorAll("div[x-ref='restore']").forEach(
                elem => elem.addEventListener("click", (event) => {
                  this.setMaximized(false);
                  this.desktop.bringToFront(this.target);
                  event.stopImmediatePropagation();
                })
              )
              // Close buttons
              // this.target.querySelectorAll("[x-ref='close']").forEach(
              //   elem => elem.addEventListener("click", () => {
              //     this.desktop.panes = this.desktop.panes.filter(p => p !== this);
              //     this.target.remove();
              //     this.desktop.save();
              //   })
              // )
              // Swap maximize/restore buttons on maximize-restore-group
              this.target.querySelectorAll("[x-ref='maximize-restore-group']").forEach(
                elem => elem.addEventListener("click", () => {
                  const button_maximize = elem.querySelector("[x-ref='maximize']");
                  const button_restore = elem.querySelector("[x-ref='restore']");
                  if (this.maximized) {
                    button_maximize.style.display = "none";
                    button_restore.style.display = "block";
                  } else {
                    button_maximize.style.display = "block";
                    button_restore.style.display = "none";
                  }
                })
              )
              // Taskbar button
              if (this.taskbar) {
                this.taskbar.addEventListener("click", () => {
                  this.desktop.bringToFront(this.target);
                  this.setMinimized(false);
                })
              }
            }

            /**
             * Generate JSON representation of the pane's state for storing
             * @returns {object} JSON object representing the state of the pane
             */
            toJSON() {
              return {
                id: this.id,
                transform: this.transform,
                z: this.z,
                width: this.width,
                height: this.height,
                minimized: this.minimized,
                maximized: this.maximized,
                focused: this.focused
              }
            }

            /**
             * Assignment operator that restores the state of the pane from a JSON object
             * @param {object} other JSON object to restore from
             */
            restore(other) {
              this.transform = other.transform;
              this.z = other.z;
              this.width = other.width;
              this.height = other.height;
              this.minimized = other.minimized;
              this.maximized = other.maximized;
              this.focused = other.focused;
              this.moveable.draggable = !other.maximized
              this.moveable.resizable = !other.maximized;
              this.render();
            }

            /**
             * Closes the pane by removing its elements from the DOM and desktop state
             */
            close() {
              // this.desktop.panes = this.desktop.panes.filter(p => p !== this);
              // this.target.remove();
              // this.taskbar.remove();
              // this.desktop.save();
            }

            /**
             * Sets the z-index of the pane and updates the DOM
             * @param {number} value Z-index to set
             */
            setZ(value) {
              this.z = value;
              this.render();
            }

            /**
             * Sets the minimized state of the pane and updates the DOM
             * @param {boolean} value True if pane should be hidden, false to use previous state
             */
            setMinimized(value) {
              this.minimized = value;
              if (value) this.focused = false;
              this.render();
              this.desktop.save();
            }
            
            /**
             * Sets the maximized state of the pane and updates the DOM
             * @param {boolean} value True if pane should be maximized, false to use previous state
             */
            setMaximized(value) {
              this.maximized = value;
              this.moveable.draggable = !value;
              this.moveable.resizable = !value;
              this.render();
              this.desktop.save();
            }

            /**
             * Sets whether the pane is focused or not
             * @param {boolean} value True if the pane is focused, false if not
             */
            setFocused(value) {
              this.focused = value;
              this.render();
              this.desktop.save();
            }

            /**
             *  Updates the DOM to reflect the current state of the pane
             */
            render() {
              // Set z-indices of pane and moveable controls
              this.target.style.zIndex = this.z;
              this.moveable.selfElement.style.zIndex = this.z;
              // Swap maximize/restore buttons
              this.target.querySelectorAll("[x-ref='maximize-restore-group']").forEach(
                elem => {
                  const button_maximize = elem.querySelector("[x-ref='maximize']");
                  const button_restore = elem.querySelector("[x-ref='restore']");
                  if (this.maximized) {
                    button_maximize.style.display = "none";
                    button_restore.style.display = "block";
                  } else {
                    button_restore.style.display = "none";
                    button_maximize.style.display = "block";
                  }
                }
              )
              if (this.maximized) {
                this.target.style.transform = `translate(0px, 0px)`;
                this.target.style.width = "100%";
                this.target.style.height = "100%";
              } else {
                this.target.style.transform = this.transform;
                this.target.style.width = this.width;
                this.target.style.height = this.height;
              }
              if (this.minimized) {
                this.target.style.display = "none";
              } else {
                this.target.style.display = "flex";
              }
              // Set color of focused pane handle
              if (this.focused) {
                this.target.classList.add("card-tertiary");
                if (this.taskbar) this.taskbar.classList.add("pane-focused");
              } else {
                this.target.classList.remove("card-tertiary");
                if (this.taskbar) this.taskbar.classList.remove("pane-focused");
              }
              this.moveable.updateRect();
            }
          }

          class Desktop {
            constructor(id) {
              this.id = id;
              this.z_next = 1000;
              this.panes = [];
              // TODO
              // this.first_load = true;
              // this.user = "";
            }

            add(pane) {
              pane.desktop = this;
              pane.setZ(this.z_next);
              this.z_next += 1;
              this.panes.push(pane);
            }

            bringToFront(pane_target) {
              const idx = this.panes.findIndex(p => p.target === pane_target);
              if (idx < 0) return;
              const pane = this.panes[idx]
              const pane_z_old = pane.z;
              // Find all panes with z-index > pane_z_old and decrement them
              this.panes.forEach(p => {
                p.setFocused(false);
                if (p.z > pane_z_old) p.setZ(p.z - 1);
              })
              // Set new active pane to top
              pane.setFocused(true);
              pane.setZ(this.z_next - 1);
            }

            save() {
              localStorage.setItem(`desktop-${this.id}`, JSON.stringify(this));
            }

            restore() {
              const saved_desktop = JSON.parse(localStorage.getItem(`desktop-${this.id}`));
              if (!saved_desktop) return;
              this.id = saved_desktop.id;
              this.z_next = saved_desktop.z_next;
              const saved_panes = saved_desktop.panes;
              // Reopen all panes
              saved_panes.forEach(saved_pane => {
                // TODO: we would just construct panes here instead of restoring them
                // TODO: constructed panes should also link the constructed Pane in its target
                const pane = this.panes.find(pane => pane.id === saved_pane.id);
                if (pane)
                  pane.restore(saved_pane);
              })
            }

            reset() {
              localStorage.removeItem(`desktop-${this.id}`);
              window.location.reload();
            }
          }

          // 1. Create default Desktop and add Panes
          this.desktop = new Desktop("index");
          this.desktop.add(new Pane({
            id: "challenges", // TODO: generate this uniquely
            target: this.$refs.paneChallenges,
            handle: this.$refs.paneChallengesHandle,
            taskbar: this.$refs.taskbarChallenges,
            title: "Challenges",
            icon_path: "/themes/uiuctf-2023-ctfd-theme/static/img/uiuctf-2023-pwny.svg"
          }));
          this.desktop.add(new Pane({
            id: "scoreboard", // TODO: generate this uniquely
            target: this.$refs.paneScoreboard,
            handle: this.$refs.paneScoreboardHandle,
            taskbar: this.$refs.taskbarScoreboard,
            title: "Scoreboard",
            icon_path: "/themes/uiuctf-2023-ctfd-theme/static/img/uiuctf-2023-pwny.svg"
          }));
          // ...
          // 2. restore states from localStorage
          this.desktop.restore();
        }
      }))
    })
  </script>
{% endblock head %}
<!-- End base -->

{% block page %}
  <div class="min-vh-100 d-flex flex-column bg-secondary" x-data="mydata">
    <main class="d-flex flex-grow-1 w-100 flex-column" x-ref="desktop">
      <!-- Desktop background -->
      <section class="d-flex bg-secondary w-100">

        <!-- Challenges pane -->
        <div class="card pane flex-column" x-ref="paneChallenges">
          <div class="card-header d-flex flex-row justify-content-between align-items-center" x-ref="paneChallengesHandle">
            <div class="card-header-content">
              Challenges
            </div>
            <div class="d-flex flex-row">
              <div class="pane-control-icon" x-ref="minimize">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/minimize.png" alt="">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/minimize_pressed.png" alt="">
              </div>
              <span x-ref="maximize-restore-group">
                <div class="pane-control-icon" x-ref="maximize">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/maximize.png" alt="">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/maximize_pressed.png" alt="">
                </div>
                <div class="pane-control-icon" x-ref="restore">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/restore.png" alt="">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/restore_pressed.png" alt="">
                </div>
              </span>
              <div class="pane-control-icon close-icon" x-ref="close">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/close.png" alt="">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/close_pressed.png" alt="">
              </div>
            </div>
          </div>
          <div class="card-body">
            <span>Current things to do:</span>
            <ul>
              <li>
                Once open/unminimize functionality is added, change all panes to start closed/minimized
                to prevent flash of initial state to restored render state.
              </li>
              <li>
                You can still drag the handle/target pane when holding down any of the control buttons.
                Double click to maximize/restore also happens when clicking on the control buttons.
                <br />
                <br />
                Possible solutions: event handler to prevent "bubbling" of events to parent, or remove
                control buttons from the handle somehow (but visually keep them in the same place).
              </li>
              <li>
                Nice to have: stagger where panes initially open, so they all don't just start at (0, 0).
              </li>
              <li>
                Nice to have: actually implement "open/closed" state, instead of just being an alias for minimizing.
                This may involve shenanigans like removing the pane from the DOM when closed.
              </li>
            </ul>
            <span>Test buttons not on handle:</span>
            <div class="d-flex flex-row">
              <div class="pane-control-icon" x-ref="minimize">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/minimize.png" alt="">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/minimize_pressed.png" alt="">
              </div>
              <span x-ref="maximize-restore-group">
                <div class="pane-control-icon" x-ref="maximize">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/maximize.png" alt="">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/maximize_pressed.png" alt="">
                </div>
                <div class="pane-control-icon" x-ref="restore">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/restore.png" alt="">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/restore_pressed.png" alt="">
                </div>
              </span>
              <div class="pane-control-icon close-icon" x-ref="close">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/close.png" alt="">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/close_pressed.png" alt="">
              </div>
            </div>
          </div>
        </div>

        <!-- Scoreboard pane -->
        <div x-ref="paneScoreboard" class="card pane">
          <div x-ref="paneScoreboardHandle" class="card-header d-flex flex-row justify-content-between align-items-center">
            <span>Scoreboard</span>
            <div class="d-flex flex-row">
              <div class="pane-control-icon" x-ref="minimize">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/minimize.png" alt="">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/minimize_pressed.png" alt="">
              </div>
              <span x-ref="maximize-restore-group">
                <div class="pane-control-icon" x-ref="maximize">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/maximize.png" alt="">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/maximize_pressed.png" alt="">
                </div>
                <div class="pane-control-icon" x-ref="restore">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/restore.png" alt="">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/restore_pressed.png" alt="">
                </div>
              </span>
              <div class="pane-control-icon close-icon" x-ref="close">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/close.png" alt="">
                <img src="/themes/uiuctf-2023-ctfd-theme/static/img/win95-pane-control/close_pressed.png" alt="">
              </div>
            </div>
          </div>
          <div class="card-body">
            <span>Test</span>
          </div>
        </div>

      </section>
    </main>

    <!-- Taskbar -->
    <footer class="d-flex position-relative">
      <nav id="taskbar" class="navbar navbar-main navbar-expand-lg navbar-dark justify-content-between navbar-footer user-select-none">
        <ul class="navbar-nav">
          <li class="nav-item start-button">
            <div class="start-menu-container">
              <div class="start-menu">
                <div class="logo-bar">
                  <img src="/themes/uiuctf-2023-ctfd-theme/static/img/start-menu-logo-sideways.png" />
                </div>
                <div class="main-options">
                  <div>
                    <span>
                      Challenges
                    </span>
                  </div>
                  <div>
                    <span>
                      Scoreboard
                    </span>
                  </div>
                  <div>
                    <span>
                      Users
                    </span>
                  </div>
                  <div>
                    <span>
                      Teams
                    </span>
                  </div>
                  <div>
                    <span>
                      Settings
                    </span>
                  </div>
                  <div>
                    <span>
                      Help
                    </span>
                  </div>
                  <div>
                    <span>
                      Log in...
                    </span>
                  </div>
                </div>
              </div>
            </div>
            <a href="index.html" class="nav-link d-flex flex-row" role="button">
              <img class="taskbar-icon" src="/themes/uiuctf-2023-ctfd-theme/static/img/uiuctf-2023-pwny.svg" />
              <div>Start</div>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" role="button" x-ref="taskbarChallenges">
              <div>🔐 Challenges</div>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" role="button" x-ref="taskbarScoreboard">
              <div>📈 Scoreboard</div>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" role="button">
              <div>ℹ️ Info</div>
            </a>
          </li>
          <li class="nav-item">
            <a class="nav-link" role="button">
              <div>My Account</div>
            </a>
          </li>
        </ul>
        <div id="time" class="time text-center">12:00 AM</div>
      </nav>
    </footer>
  </div>
{% endblock %}

{% block scripts %}
  {{ Assets.js("assets/js/challenges.js") }}
  <script type="text/javascript">
    function refreshTime() {
      const time = new Date().toLocaleTimeString([], {hour: "numeric", minute:'2-digit'});
      document.getElementById("time").innerText = time;
    }
    if (document.getElementById("time")) {
      refreshTime();
      setInterval(refreshTime, 5000)
    }
  </script>
{% endblock %}
